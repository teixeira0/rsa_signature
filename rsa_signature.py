# Cifra AES
# Rodrigo Teixeira Soares	19/0019760

import sys
import random
import hashlib
import math

sbox = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    ]

inverse_sbox = [
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
]

times_9 = [
	0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,	
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,	
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,	
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
]

times_11 = [
	0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
]

times_13 = [
	0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
]

times_14 = [
	0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
]

rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]

def generate_aes_key():
	key = []
	for i in range(128):
		key.append(str(random.randint(0,1)))
	print("Generated key:")
	print((int(''.join(key),2)).to_bytes(16))
	key = bytearray((int(''.join(key),2)).to_bytes(16))
	return key

def rotword(word):
	result = bytearray([word[1], word[2], word[3], word[0]])
	return result

def subword(word):
	result = bytearray([sbox[word[0]], sbox[word[1]], sbox[word[2]], sbox[word[3]]])
	return result

def key_schedule(key):
	key_words = [key[0:4], key[4:8], key[8:12], key[12:16]]
	for i in range(44)[4:]:
		newword = bytearray()
		if (i % 4 == 0):
			new_word = bytearray([a ^ b ^ c for a,b,c in zip(key_words[i-4], subword(rotword(key_words[i-1])),bytearray([rcon[(i//4)-1],0,0,0]))])
		else:
			new_word = bytearray([a ^ b for a,b in zip(key_words[i-4], key_words[i-1])])
		key_words.append(new_word)
	expanded_key = [b''.join(key_words[0:4]), b''.join(key_words[4:8]), b''.join(key_words[8:12]), b''.join(key_words[12:16]), b''.join(key_words[16:20]), b''.join(key_words[20:24]), b''.join(key_words[24:28]), b''.join(key_words[28:32]), b''.join(key_words[32:36]), b''.join(key_words[36:40]), b''.join(key_words[40:44])]
	print("Expanded key:")
	print([onekey.hex() for onekey in expanded_key])

	return expanded_key

def add_round_key(key, state):
	state = bytearray([a ^ b for a, b in zip(key, state)])
	return state

def s_box(state):
	state = bytearray([sbox[a] for a in state])
	return state

def inverse_s_box(state):
	state = bytearray([inverse_sbox[a] for a in state])
	return state

def shift_rows(state):
	rows = [bytearray([state[0], state[4], state[8], state[12]]), [state[1], state[5], state[9], state[13]], [state[2], state[6], state[10], state[14]], [state[3], state[7], state[11], state[15]]]
	# Row 1
	rows[1] = bytearray([rows[1][1], rows[1][2], rows[1][3], rows[1][0]])
	# Row 2
	rows[2] = bytearray([rows[2][2], rows[2][3], rows[2][0], rows[2][1]])
	# Row 3
	rows[3] = bytearray([rows[3][3], rows[3][0], rows[3][1], rows[3][2]])
	state = bytearray([rows[0][0], rows[1][0], rows[2][0], rows[3][0], rows[0][1], rows[1][1], rows[2][1], rows[3][1], rows[0][2], rows[1][2], rows[2][2], rows[3][2], rows[0][3], rows[1][3], rows[2][3], rows[3][3]])
	return state

def inverse_shift_rows(state):
	rows = [bytearray([state[0], state[4], state[8], state[12]]), [state[1], state[5], state[9], state[13]], [state[2], state[6], state[10], state[14]], [state[3], state[7], state[11], state[15]]]
	# Row 1
	rows[1] = bytearray([rows[1][3], rows[1][0], rows[1][1], rows[1][2]])
	# Row 2
	rows[2] = bytearray([rows[2][2], rows[2][3], rows[2][0], rows[2][1]])
	# Row 3
	rows[3] = bytearray([rows[3][1], rows[3][2], rows[3][3], rows[3][0]])
	state = bytearray([rows[0][0], rows[1][0], rows[2][0], rows[3][0], rows[0][1], rows[1][1], rows[2][1], rows[3][1], rows[0][2], rows[1][2], rows[2][2], rows[3][2], rows[0][3], rows[1][3], rows[2][3], rows[3][3]])
	return state

def mix_columns(state):
	columns = [state[0:4], state[4:8], state[8:12], state[12:16]]
	new_columns = []
	for column in columns:
		times_two = [0, 0, 0, 0]
		for i in range(4):
			has_high_bit = (column[i] >> 7) & 1
			times_two[i] = column[i] << 1
			times_two[i] ^= has_high_bit * 0x11b
		new_column = bytearray([0, 0, 0, 0])
		new_column[0] = times_two[0] ^ column[3] ^ column[2] ^ times_two[1] ^ column[1]
		new_column[1] = times_two[1] ^ column[0] ^ column[3] ^ times_two[2] ^ column[2]
		new_column[2] = times_two[2] ^ column[1] ^ column[0] ^ times_two[3] ^ column[3]
		new_column[3] = times_two[3] ^ column[2] ^ column[1] ^ times_two[0] ^ column[0]
		new_columns.append(new_column)
	state = bytearray(b''.join(new_columns))
	return state

def inverse_mix_columns(state):
	columns = [state[0:4], state[4:8], state[8:12], state[12:16]]
	new_columns = []
	for column in columns:
		new_column = bytearray([0, 0, 0, 0])
		new_column[0] = times_14[column[0]] ^ times_11[column[1]] ^ times_13[column[2]] ^ times_9[column[3]]
		new_column[1] = times_9[column[0]] ^ times_14[column[1]] ^ times_11[column[2]] ^ times_13[column[3]]
		new_column[2] = times_13[column[0]] ^ times_9[column[1]] ^ times_14[column[2]] ^ times_11[column[3]]
		new_column[3] = times_11[column[0]] ^ times_13[column[1]] ^ times_9[column[2]] ^ times_14[column[3]]
		new_columns.append(new_column)
	state = bytearray(b''.join(new_columns))
	return state

# This function cyphers a given message in AES
def aes_cypher(message):
	print("Cyphering...")
	key = generate_aes_key()
	print("Key:")
	print(key.hex())
	message_bytes = bytearray.fromhex(message.encode().hex())
	print("Hex message:")
	print(message_bytes.hex())
	expanded_key = key_schedule(key)
	# First round
	state  = add_round_key(expanded_key[0], message_bytes)
	print("Add round key:")
	print(state.hex())
	for i in range(1,11):
		state = s_box(state)
		print("Round " + str(i) + " after S-box:")
		print(state.hex())
		state = shift_rows(state)
		print("Round " + str(i) + " after shift rows:")
		print(state.hex())
		if (i != 10):
			state = mix_columns(state)
			print("Round " + str(i) + " after mix columns:")
			print(state.hex())
		state  = add_round_key(expanded_key[i], state)
		print("Round " + str(i) + " after add round key:")
		print(state.hex())

	print("Cypher complete!")
	return state.hex(), key.hex()

# This function decyphers a given message in AES
def aes_decypher(message, key):
	print("Decyphering...")
	state = bytearray.fromhex(message)
	expanded_key = key_schedule(bytearray.fromhex(key))
	for i in range(10,0,-1):
		state  = add_round_key(expanded_key[i], state)
		print("Round " + str(i) + " after add round key:")
		print(state.hex())
		if (i != 10):
			state = inverse_mix_columns(state)
			print("Round " + str(i) + " after mix columns:")
			print(state.hex())
		state = inverse_shift_rows(state)
		print("Round " + str(i) + " after shift rows:")
		print(state.hex())
		state = inverse_s_box(state)
		print("Round " + str(i) + " after S-box:")
		print(state.hex())
	state  = add_round_key(expanded_key[0], state)
	print("Last round after add round key:")
	print(state.hex())
	print("Decyphered message:")
	print(state.decode("ascii"))
	print("Decyphering complete!")
	return state.decode("ascii")


def miller_rabin(num):
	n = num - 1
	s = 0
	d = 0
	while n % 2 == 0:
		n //= 2
		s += 1
	d = n
	for i in range(100):
		a = random.randint(2, num-2)
		x = pow(a,d,num)
		y = 0
		for j in range(s):
			y = pow(x, 2, num)
			if y == 1 and x != 1 and x != num - 1:
				return False
			x = y
		if y != 1:
			return False
	return True

def generate_rsa_key():
	prime1 = False
	prime2 = False
	num1 = 0
	num2 = 0
	print("Generating prime 1:")
	while not prime1:
		num1 = random.getrandbits(1024)
		# It is not prime if it is even
		if num1 % 2 == 0:
			num1 += 1
		prime1 = miller_rabin(num1)
	print("Generating prime 2:")
	while not prime2:
		num2 = random.getrandbits(1024)
		# It is not prime if it is even
		if num2 % 2 == 0:
			num2 += 1
		prime2 = miller_rabin(num2)	
	n = num1*num2
	carmichael = math.lcm(num1-1, num2-1)
	e = 65537
	d = pow(e, -1, carmichael)
	public_key = [n, e]
	secret_key = d
	print("P:")
	print(num1)
	print("Q:")
	print(num2)	
	return public_key, secret_key

def mgf1(seed, length):
	hlen = hashlib.sha3_256().digest_size
	if length > (hlen << 32):
		raise ValueError("mask too long")
	T = b""
	counter = 0
	while len(T) < length:
		C = int.to_bytes(counter, 4, 'big')
		T += hashlib.sha3_256(seed + C).digest()
		counter += 1
	return T[:length]

def oaep(message, k):
	# Hash L = ''
	m = hashlib.sha3_256()
	m.update(b'')
	lhash = bytearray.fromhex(m.hexdigest())
	print(k)
	print(len(message))
	print(len(lhash))
	ps = bytearray(k - len(message) - 2*len(lhash) - 2)
	db = lhash + ps + bytearray([0x01]) + message
	seed = bytearray(random.getrandbits(len(lhash)*8).to_bytes(len(lhash)))
	dbMask = mgf1(seed, len(db))
	maskedDB = bytearray([a ^ b for a, b in zip(db, dbMask)])
	seedMask = mgf1(maskedDB, len(lhash))
	maskedSeed = bytearray([a ^ b for a, b in zip(seed, seedMask)])
	return bytearray([0x00]) + maskedSeed + maskedDB

def inverse_oaep(message, k):
	# Hash L = ''
	m = hashlib.sha3_256()
	m.update(b'')
	lhash = bytearray.fromhex(m.hexdigest())
	maskedSeed = bytearray(message[1:len(lhash)+1])
	maskedDB = bytearray(message[len(lhash)+1:])
	seedMask = mgf1(maskedDB, len(lhash))
	seed = bytearray([a ^ b for a, b in zip(maskedSeed, seedMask)])
	dbMask = mgf1(seed, k - len(lhash) - 1)
	db = bytearray([a ^ b for a, b in zip(maskedDB, dbMask)])
	if lhash == db[0:len(lhash)]:
		print("LHash match!")
	else:
		print("LHash not match!")
	rest_of_db = db[len(lhash):]
	PS = rest_of_db[0:rest_of_db.index(0x01)]
	print("Decoded Message:")
	decoded = rest_of_db[rest_of_db.index(0x01)+1:]
	print(decoded.hex())
	return decoded.hex()

def rsa_cypher(message, key=""):
	print("Cyphering...")
	public_key = []
	secret_key = 0
	if not len(key):
		print("Generating new RSA key...")
		public_key, secret_key = generate_rsa_key()
	else:
		print("Using provided public key for encryption.")
		public_key = [int(key[0]), int(key[1])]
	n, e = (public_key[0], public_key[1])
	state = oaep(bytearray.fromhex(message), math.ceil(n.bit_length()/8))
	print("OAEP Encoded message:")
	print(state.hex())
	c = pow(int.from_bytes(state), e, n)
	c = c.to_bytes(len(state)).hex()
	print("RSA Cyphered text:")
	print(c)
	return c, public_key, secret_key

def rsa_decypher(message, public_key, secret_key):
	print("Decyphering...")
	print("Cyphered message:")
	print(message)
	n = int(public_key[0])
	print("Modulus:")
	print(n)
	m = pow(int.from_bytes(bytearray.fromhex(message)), int(secret_key), n)
	m = m.to_bytes(len(bytearray.fromhex(message)))
	print("Unpadded message:")
	print(m)
	state = inverse_oaep(m, math.ceil(n.bit_length()/8))
	return state

def rsa_sign(message, secret_key, n):
	m = pow(int.from_bytes(bytearray.fromhex(message)), int(secret_key), n)
	m = m.to_bytes(len(bytearray.fromhex(message)))
	return m.hex()

def rsa_reverse_sign(message, public_key):
	n, e = (int(public_key[0]), int(public_key[1]))
	m = pow(int.from_bytes(bytearray.fromhex(message)), e, n)
	m = m.to_bytes(len(bytearray.fromhex(message)))
	return m.hex()

# python3 rsa_signature.py 1/2/3/4/5 c/d message.txt key.txt [secret_key.txt] [key_b.txt] [cyphered_key.txt] result.txt

if (len(sys.argv) != 6 and len(sys.argv) !=8 and len(sys.argv) !=9):
	raise Exception("Invalid arguments!")

operation = sys.argv[1]
suboperation = sys.argv[2]
message_file = sys.argv[3]
message = ""
key = ""
result = ""

with open(message_file) as f:
	message = f.read()

if (operation == "1"):
	key_file = sys.argv[4]
	result_file = sys.argv[5]
	if (suboperation == "c"):
		result, key = aes_cypher(message) 
		# Saving key to file
		with open(key_file, "w") as f:
			f.write(key)	
		
		# Saving to file
		with open(result_file, "w") as f:
			f.write(result)
	elif (suboperation == "d"):
		with open(key_file) as f:
			key = f.read()
		result = aes_decypher(message, key) 
		
		# Saving to file
		with open(result_file, "w") as f:
			f.write(result)
	else:
		raise Exception("Invalid sub operation!")

elif (operation == "2"):
	key_file = sys.argv[4]
	secret_key_file = sys.argv[5]
	cyphered_key_file = sys.argv[6]
	result_file = sys.argv[7]
	if (suboperation == "c"):
		result, key = aes_cypher(message) 
		with open(key_file) as f:
			public_key = f.readlines()
		cyphered_key, public_key, secret_key = rsa_cypher(key, public_key)

		with open(key_file, "w") as f:
			f.write(str(public_key[0]))
			f.write("\n")
			f.write(str(public_key[1]))

		if (secret_key != 0):
			with open(secret_key_file, "w") as f:
				f.write(str(secret_key))

		# Saving to file
		with open(result_file, "w") as f:
			f.write(str(result))
		with open(cyphered_key_file, "w") as f:
			f.write(str(cyphered_key))
	elif (suboperation == "d"):
		public_key = ""
		secret_key = ""
		cyphered_key = ""
		with open(key_file) as f:
			public_key = f.readlines()
		with open(secret_key_file) as f:
			secret_key = f.read()
		with open(cyphered_key_file) as f:
			cyphered_key = f.read()
		key = rsa_decypher(cyphered_key, public_key, secret_key)
		result = aes_decypher(message, key)

		# Saving to file
		with open(result_file, "w") as f:
			f.write(str(result))

	else:
		raise Exception("Invalid sub operation!")

elif (operation == "3"):
	key_file = sys.argv[4]
	secret_key_file = sys.argv[5]
	key_file_b = sys.argv[6]
	cyphered_key_file = sys.argv[7]
	result_file = sys.argv[8]
	if (suboperation == "c"):
		result, key = aes_cypher(message) 
		with open(key_file) as f:
			public_key_a = f.readlines()
		cyphered_key_a, public_key_a, secret_key_a = rsa_cypher(key, public_key_a)
		print("RSA Cyphered message:")
		print(cyphered_key_a)
		public_key_b, secret_key_b = generate_rsa_key()
		cyphered_key_b = rsa_sign(cyphered_key_a, secret_key_b, int(public_key_b[0]))
		with open(key_file, "w") as f:
			f.write(str(public_key_a[0]))
			f.write("\n")
			f.write(str(public_key_a[1]))

		if (secret_key_a != 0):
			with open(secret_key_file, "w") as f:
				f.write(str(secret_key_a))

		with open(key_file_b, "w") as f:
			f.write(str(public_key_b[0]))
			f.write("\n")
			f.write(str(public_key_b[1]))

		# Saving to file
		with open(result_file, "w") as f:
			f.write(str(result))
		with open(cyphered_key_file, "w") as f:
			f.write(str(cyphered_key_b))
	elif (suboperation == "d"):
		public_key_a = ""
		secret_key_a = ""
		public_key_b = ""
		secret_key_b = ""
		cyphered_key = ""
		with open(key_file) as f:
			public_key_a = f.readlines()
		with open(secret_key_file) as f:
			secret_key_a = f.read()
		with open(key_file_b) as f:
			public_key_b = f.readlines()
		with open(cyphered_key_file) as f:
			cyphered_key_b = f.read()
		cyphered_key_a = rsa_reverse_sign(cyphered_key_b, public_key_b)
		print("RSA Cyphered message:")
		print(cyphered_key_a)
		key = rsa_decypher(cyphered_key_a, public_key_a, secret_key_a)
		print(message)
		result = aes_decypher(message, key)

		# Saving to file
		with open(result_file, "w") as f:
			f.write(str(result))

	else:
		raise Exception("Invalid sub operation!")
else:
	raise Exception("Invalid operation!")
